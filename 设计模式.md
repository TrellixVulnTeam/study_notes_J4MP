### 设计模式七大基本原则

- 单一职责原则
  - 就一个类而言，应该仅有一个引起它变化的原因。
  - 软件设计真正要做的许多内容，就是发现职责并把哪些职责相互分离
  - 如果你能想到多余一个的动机去改变一个类，那么这个类就具有多余一个的职责，就应该考虑类的职责分离
- 开放-封闭原则
  - 软件实体（类、模块、函数等等）应该可以扩展，但是不可修改
  - 对扩展是开放的，对更改是封闭的
  - 无论模块是多么的”封闭“，都会存在一些无法对之封闭的变化，既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。
  - 精神：面对需求，对程序的改动是通过新代码来进行的，而不是更改现有的代码。这就是OCP的精神所在。
  - 开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于程序中的每个部分都刻意的进行抽象同样不是一个好主意，拒绝不成熟的抽象和抽象本身一样重要。
- 依赖倒置原则
  - 抽象不应该依赖细节，细节应该依赖于抽象。----> 针对接口编程，不要针对实现编程
  - 高层模块不应该依赖于低层模块，两个都应该依赖于抽象。
- 里氏代换原则
  - 子类型必须能够替换掉它们的父类型。
- 接口隔离原则
- 迪米特原则
- 组合/聚合复用原则

### 设计模式

#### 1. 简单工厂模式

![image-20210621200653955](C:\Users\killa\AppData\Roaming\Typora\typora-user-images\image-20210621200653955.png)

#### 2. 策略模式

![image-20210621200714579](C:\Users\killa\AppData\Roaming\Typora\typora-user-images\image-20210621200714579.png)

![image-20210621200801694](C:\Users\killa\AppData\Roaming\Typora\typora-user-images\image-20210621200801694.png)

#### 3. 装饰模式

- 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活

- 结构图

  ![image-20210621202151594](C:\Users\killa\AppData\Roaming\Typora\typora-user-images\image-20210621202151594.png)

- 如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类，同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。

- 总结：

  - 装饰模式是为已有功能动态地添加更多功能的一种方式
  - 当系统需要新功能的时候，是向旧的类中添加新的代码。这些新的代码通常装饰了原有类的核心职责或者主要行为，而这些新加入的的东西仅仅是为了满足一些只在特定情况下才会执行的特殊行为的需要。
  - 而装饰模式提供了一个非常好的解决方案，它把每个需要装饰的功能放在单独的类中，并让这个类包装它所需要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择得，按顺序得使用装饰功能包装对象了。

#### 4. 代理模式

- 为其他对象提供一种代理以控制对这个对象的访问。

- 结构图

  ![image-20210621210117049](C:\Users\killa\AppData\Roaming\Typora\typora-user-images\image-20210621210117049.png)

- 用途

  - 远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实（webservice）
  - 虚拟代理：根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象（网页中的图片）
  - 安全代理：用来控制真实对象访问时的权限
  - 智能指引：当调用真实的对象时，代理处理另外一些事

#### 5. 工厂方法模式

- 

